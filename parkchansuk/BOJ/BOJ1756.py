# BOJ 1756. 피자 굽기 / D3
'''
월드피자 원주 지점에서 N개의 피자 반죽을 오븐에 넣고 구우려고 한다.
그런데, 월드피자에서 만드는 피자 반죽은 지름이 제각각이다.
그런가하면, 월드피자에서 사용하는 오븐의 모양도 몹시 오묘하다.
이 오븐은 깊은 관처럼 생겼는데, 관의 지름이 깊이에 따라 들쭉날쭉하게 변한다.
아래는 오븐의 단면 예시이다.



피자 반죽은 완성되는 순서대로 오븐에 들어간다.
이렇게 N개의 피자가 오븐에 모두 들어가고 나면, 맨 위의 피자가 얼마나 깊이 들어가 있는지가 궁금하다. 이를 알아내는 프로그램을 작성하시오.

입력
첫째 줄에 오븐의 깊이 D와 피자 반죽의 개수 N이 공백을 사이에 두고 주어진다. (1 ≤ D, N ≤ 300,000) 둘째 줄에는 오븐의 최상단부터 시작하여 깊이에 따른 오븐의 지름이 차례대로 주어진다. 셋째 줄에는 피자 반죽이 완성되는 순서대로, 그 각각의 지름이 주어진다. 오븐의 지름이나 피자 반죽의 지름은 10억 이하의 자연수이다.

출력
첫째 줄에, 마지막 피자 반죽의 위치를 출력한다. 오븐의 최상단이 1이고, 최하단 가장 깊은 곳이 D이 된다. 만약 피자가 모두 오븐에 들어가지 않는다면, 0을 출력한다.
'''
import sys
input = sys.stdin.readline

D, N = map(int, input().split())
oven = list(map(int, input().split()))
pizza = list(map(int, input().split()))

for i in range(1, D): # 오븐의 크기 전처리, ex) 5 밑에 6이 있으면 어차피 5이상 못들어가므로 6을 5로 변경
    if oven[i-1] < oven[i]:
        oven[i] = oven[i-1]

current = D-1 # 맨 밑에서 부터 판단하기 위함, 현재 위치 표시
last_pizza = -1 # 출력을 위함

for r in pizza: # 피자 하니씩 뽑아서 확인
    while current > 0 and oven[current] < r: # 현재 위치에서 피자가 오븐보다 크다면
        current -= 1 # 위로 올라간다, 언제까지? -> 오븐의 크기가 피자보다 크거나 같아지는 상황 또는 current가 음수가 될때

    if current >= 0 and oven[current] >= r: # current가 음수가 아니고 피자 사이즈가 오븐과 같거나 작을때
        last_pizza = current # 현재 위치가 마지막으로 피자를 넣은 위치가 된다
        current -= 1 # 다음 피자 판단을 위해 한칸 올려줌

    if current < 0: # 만약에 하나라도 피자가 안들어가는 경우
        last_pizza = -1 # 0을 출력해야하기 때문에 -1로 설정

print(last_pizza+1) # 인덱스 값이므로 +1을 해줘야 답이 나옴

'''
오븐 전처리 과정이 중요하다 생각함.
위보다 큰 반지름을 가지고 있더라도 그 크기가 들어오지 못하기때문에
위 반지름 크기에 맞게 조정함
이후 밑에서 부터 확인하며
들어갈 수 있는지 판단을 하고 들어간다면 넣도 다음피자 확인
하나라도 못들어가면 0 출력
'''
'''
문제 이해를 잘못해서 틀렸습니다. 3번 봄
문제를 피자를 넣다가 안들어가는 피자가 나오면 마지막으로 내가 넣은 피자의 위치를 출력하는 줄 알았는데
1개라도 피자가 안들어가면 답으로 0 출력해야함....
말을 다시 써야함...
"만약 피자가 모두 오븐에 들어가지 않는다면, 0을 출력한다." 이게 아니라
"만약 모든 피자가 오븐에 들어가지 않는다면, 0을 출력한다." 이렇게 써야하는거 아닌가?
'''