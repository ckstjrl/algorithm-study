"""
BOJ17298. 오큰수

[문제]
크기가 N인 수열 A = A1, A2, ..., AN이 있다. 수열의 각 원소 Ai에 대해서 오큰수 NGE(i)를 구하려고 한다.
Ai의 오큰수는 오른쪽에 있으면서 Ai보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오큰수는 -1이다.
예를 들어, A = [3, 5, 2, 7]인 경우 NGE(1) = 5, NGE(2) = 7, NGE(3) = 7, NGE(4) = -1이다.
A = [9, 5, 4, 8]인 경우에는 NGE(1) = -1, NGE(2) = 8, NGE(3) = 8, NGE(4) = -1이다.

[입력]
첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.
둘째 줄에 수열 A의 원소 A1, A2, ..., AN (1 ≤ Ai ≤ 1,000,000)이 주어진다.

[출력]
총 N개의 수 NGE(1), NGE(2), ..., NGE(N)을 공백으로 구분해 출력한다.
"""

import sys
input = lambda: sys.stdin.readline().rstrip()

# main
N = int(input())    # 수열 A의 크기
A = list(map(int, input().split())) # 수열 입력 받기

stack = []  # 아직 오큰수를 찾지 못한 인덱스를 저장하는 스택
ans = [-1] * N  # 결과 배열을 -1(오큰수 없음)로 초기화

for i in range(N):  # 모든 수열의 각 원소들을 순서대로 순회하면서,
    
    # 1. 앞 인덱스들의 오큰수가 현재 숫자 A[i]인지 검사하기
    while stack and A[stack[-1]] < A[i]:    # stack이 비어 있지 않고, 스택 top의 인덱스 숫자가 현재 숫자보다 작지 않을 때까지 반복
        ans[stack.pop()] = A[i]             # stack에서 인덱스를 pop하고, 결과 배열의 해당 인덱스 위치에 현재 숫자 A[i]를 오큰수로 저장

    # 2. 현재 인덱스를 스택에 넣기(지금은 오큰수를 모르니까 뒤쪽에서 오큰수를 찾는다)
    stack.append(i)

# 결과 출력
print(*ans)